# Java Undo Framework

## Введение

**Java Undo Framework** это реализация паттерна **Команда** для создания в приложении цепочек Undo/Redo.

Паттерн **Команда** базируется на предположении, что все изменения субъектов приложения совершаются посредством создания объектов соответствующих команд. Объекты команд сохраняют состояние приложения, совершают необходимые изменения и последовательно сохраняются в стеке команд. Соответственно, каждая команда знает, как вернуть приложение в предыдущее состояние. До тех пор, пока модель "изменений через команды" не нарушается, всегда имеется возможность откатиться на любой момент, просто последовательно выполняя Undo, команда за командой в стеке, и вернуться обратно, выполняя Redo в направлении "вперед".

**Java Undo Framework** вдохновлен реализацией такого фреймворка на Qt, с небольшими изменениями и дополнениями. Так, добавлена шаблонная реализация UndoCommand, позволяющая создать команду для простого изменения свойства без создания класса (FunctionalCommand<V>). Кроме того, добавлена сериализация стеков (с zip-компрессией и без) в строку Base64 на базе стандартного механизма сериализации объектов Java.

## Классы

Фреймворк состоит из следующих основных классов и интерфейсов:

- class **UndoCommand**: базовый класс для команд, хранимых в стеке. Применяет команду redo/undo для атомарного изменения в документе
- class **UndoStack**: лист команд. Содержит лист последовательно добавленных команд, выполненных над определенным субъектом документа и может "откатывать" состояние документа до любого момента вперед и назад
- class **UndoGroup**: группа стеков. Группировка стеков удобна, когда приложение имеет больше, чем один документ, и необходимо для каждого хранить индивидуальное состояние undo/redo. UndoGroup имеет свойство "активный стек", позволяющий бесшовно переключаться между документами и выполнять undo/redo над каждым из них
- class **UndoManager**: Полезный класс для (де)сериализации стека. Содержит два статических метода для (де)сериализации. Кроме того, дополнительная информация, которую можно сохранить в менеджере при сериализации, позволяет узнать, как правильно интерпретировать субъекты на стороне десериализации, в частности - версию субъектов (что полезно при миграции данных)
- interface **UndoEvents**: набор событий для подписчиков, нуждающихся в информации о событиях стека команд. Все методы дефолтные, так что подписчик не обязан реализовывать то, что ему не надо

Дополнительные классы и интерфейсы:

- class **FunctionalCommand<V>**: Удобная шаблонная команда, которая позволяет реализовать простое изменение данных без создания дополнительных классов
- interface **Getter<V>**: Вспомогательный интерфейс для свойства-геттера команды FunctionalCommand<V>
- interface **Setter<V>**: Вспомогательный интерфейс для свойства-сеттера команды FunctionalCommand<V>

## Концепции

Фреймворк поддерживает следующие концепции:

- **Один субъект - один стек**: Хранить изменения над одним субъектом в разных стеках не только нелогично, но и опасно с точки зрения устойчивости приложения при выполнении undo/redo, возможны самые разные коллизии. Поэтому в группе невозможно разместить 2 стека с одинаковым субъектом. Хотя это не поможет, если разработчик решит использовать такую потенциально опасную ситуацию для несгруппированных стеков
- **Чистое состояние**: Используется для сигнализации, что документ вошел или покинул момент, когда происходило сохранение на диск. Это можно использовать для отражения в состоянии зависимых визуальных контролов приложения (доступность кнопки "Сохранить", и т.п.)
- **Компрессия команд**: Используется для объединения однотипных последовательностей в единую команду. В текстовом документе можно воспользоваться для объединения печатания одиночных символов в команду, печатающую целое слово. В графическом многократное перемещение объекта в одно перемещение от стартовой до конечной точки
- **Макрокоманды**: Последовательность команд, выполняемых undo/redo за один раз. Это упрощает создание задач для приложений, когда совокупность взаимосвязанных команд должна быть выполнена одномоментно. К примеру, удаление/восстановление множества выделенных объектов графической сцены можно оформить как макрос "Удаление выделенных объектов".
- **Умная сериализация**:

## Howto

### Создать цепочку команд без использования макросов
Создать базовую команду типа UndoCommand, а для всех последующих указать ее, как парент. В стек добавлять только первую команду. Таким образом все последующие команды окажутся не в стеке, а в листе субкоманд первой команды, и автоматически выполнятся при вызове `UndoCommand.undo()`:

```
UndoCommand parent = new UndoCommand("Add robot");
new AddShapeCommand(doc, ShapeRectangle, parent);
new AddShapeCommand(doc, ShapeRectangle, parent);
new AddShapeCommand(doc, ShapeRectangle, parent);
new AddShapeCommand(doc, ShapeRectangle, parent);
doc.undoStack().push(parent);
```

### Создать цепочку команд с макросом

```
doc.undoStack().beginMacro("Add robot");
doc.undoStack().push(new AddShapeCommand(doc, ShapeRectangle, parent));
doc.undoStack().push(new AddShapeCommand(doc, ShapeRectangle, parent));
doc.undoStack().push(new AddShapeCommand(doc, ShapeRectangle, parent));
doc.undoStack().push(new AddShapeCommand(doc, ShapeRectangle, parent));
doc.undoStack().endMacro();
```
### UndoStack: Subject vs Context
Свойство `UndoStack.subject` предназначено для сериализации объекта вместе с историей его изменения в виде списка `UndoCommand`. Это очень удобно, но не всегда реализуемо, так как требует соблюдения ряда условий.

Во-первых, субъект должен имплементировать `Serializable`, такое требование у механизма нативной сериализации Java, на котором построена библиотека.

Во-вторых, субъект должен быть адресно-независим от системы, так как в противном случае, восстановившись в потенциально новом адресном контексте, он окажется там "чужаком".

Поясню на примере Android-приложения.

Предположим, требуется сохранить состояние кнопки на активности.

Сохранить саму кнопку мы не можем, так как `Button` не имеет маркера `Serializable`. Но это еще полбеды. После пересоздания активности, яастью которой кнопка является, наша восстановленная кнопка окажется врагом номер один для работы приложения, так как будет указывать на уже несуществующий адрес.

Свойство `UndoStack.context` предназначено как раз для решения таких задач.

Вот его реальная техника применения

#### Команда
Команда хранит не кнопку, а лишь идентификатор ее ресурса:

```java
class RadioCheckCmd extends UndoCommand {

        int activeBtnRes;
        int inactiveBtnRes;

        public RadioCheckCmd(@NotNull String text, int activeBtnRes, int inactiveBtnRes, UndoCommand parent) {
            super(text, parent);
            this.activeBtnRes = activeBtnRes;
            this.inactiveBtnRes = inactiveBtnRes;
        }

        ...

```

При создании команды передаются требуемые идентификаторы:

```java
rbMonth.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                undoStack.push(new MainUndo.RadioCheckCmd("Do monthly",
                        R.id.radioMonthly, R.id.radioYearly, null));
                setUndoState();
            }
        });
```

При десериализации в качестве контекста ожидается активность:

```java
UndoManager undoManager = UndoManager.deserialize(s, this);
```

В процессе undo/redo происходит правильная реализация команды:

```java
class RadioCheckCmd extends UndoCommand {
...
        @Override
        protected <Context> void doRedo(Context context) {
            if(context != null && context instanceof Activity) {
                Activity a = (Activity)context;
                RadioButton activeBtn = a.findViewById(activeBtnRes);
                RadioButton inactiveBtn = a.findViewById(inactiveBtnRes);
                activeBtn.setChecked(true);
                inactiveBtn.setChecked(false);
            }
        }

        @Override
        protected <Context> void doUndo(Context context) {
            if(context != null && context instanceof Activity) {
                Activity a = (Activity)context;
                RadioButton activeBtn = a.findViewById(activeBtnRes);
                RadioButton inactiveBtn = a.findViewById(inactiveBtnRes);
                inactiveBtn.setChecked(true);
                activeBtn.setChecked(false);
            }
        }
    }

    ...

```